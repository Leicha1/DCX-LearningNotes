# 1.数组理论基础
![](https://cdn.jsdelivr.net/gh/Leicha1/tuchuang/img/20250312204032.png)
==定义：==数组是存放在连续内存空间上的相同类型数据的集合。
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250318200320.png)
==注意：==
- 数组下标都是从0开始的
- 数组内存空间的地址是连续的

正是**因为数组在内存空间中的地址是连续的**，所以**在删除或者增加元素时**，**就难免需要移动其他元素的地址。**

例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250318200155.png)

**数组的元素是不能删除的，只能覆盖。**

==二维数组：==
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250318200502.png)
**在C++中，二维数组在内存中的空间地址是连续分布的**，但Java中不是
# 2.二分查找
## 题目
[704. 二分查找 - 力扣题目链接（LeetCode）](https://leetcode.cn/problems/binary-search/description/)
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
示例 1:
```
输入: nums = [-1,0,3,5,9,12], target = 9     
输出: 4       
解释: 9 出现在 nums 中并且下标为 4     
``` 
示例 2:
```
输入: nums = [-1,0,3,5,9,12], target = 2     
输出: -1        
解释: 2 不存在 nums 中因此返回 -1        
```
提示：
- 你可以假设 nums 中的所有元素是不重复的。
- n 将在 [1, 10000]之间。
- nums 的每个元素都将在 [-9999, 9999]之间。
## 思路
[手把手带你撕出正确的二分法 | 二分查找法 | 二分搜索法 | LeetCode：704. 二分查找_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1fA4y1o715/?vd_source=8c3dd385213da0072604192e9b535246)
注意题目中是==升序数组==且==数组中元素不重复==。

二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 `while(left < right)` 还是 `while(left <= right)`，到底是`right = middle`呢，还是要`right = middle - 1`呢？

二分法经常写乱，主要是因为**对区间的定义没有想清楚，区间的定义就是不变量**。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。

写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。
## 第一种解法（左闭右闭）
```
// 版本一
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```
时间复杂度O(log n)
空间复杂度O(1)
## 第二种解法（左闭右开）
```
// 版本二
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里，[left, right）
        while (left < right) { // 当left==right，区间[left, right）无效，所以用 <
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle; // target 在左区间，所以[left, middle）
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right）
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```
时间复杂度O(log n)
空间复杂度O(1)
# 3.移除元素(双指针)
## 题目
[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/description/)
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。
示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
**你不需要考虑数组中超出新长度后面的元素。**
## 思路
C++中数组的内存地址是连续的，不能单独删除数组中的某个元素，只能覆盖
## 暴力解法
两个for循环嵌套
时间复杂度O(n^2)
空间复杂度O(1)
```
// 时间复杂度：O(n^2)
// 空间复杂度：O(1)
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int size = nums.size();
        for (int i = 0; i < size; i++) {
            if (nums[i] == val) { // 发现需要移除的元素，就将数组集体向前移动一位
                for (int j = i + 1; j < size; j++) {
                    nums[j - 1] = nums[j];// 不能写成nums[j] = nums[j + 1];
                }
                i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位
                size--; // 此时数组的大小-1
            }
        }
        return size;

    }
};
```
## 双指针解法
通过定义快慢指针，在一个for循环下实现两个for循环的功能
- 快指针：寻找新数组的元素，新数组就是不含目标元素的数组
- 慢指针：指向更新后新数组下标的位置
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif)
```
// 时间复杂度：O(n)
// 空间复杂度：O(1)
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        //双指针解法
        int slow = 0;
        for(int fast = 0;fast < nums.size();fast++){
            if(nums[fast] != val) 
	            nums[slow++] = nums[fast];
        }
        return slow;
    }
};
```
# 4.有序数组的平方(双指针)
## 题目
[977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)
给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
示例 1：
- 输入：nums = [-4,-1,0,3,10]
- 输出：[0,1,9,16,100]
- 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100
示例 2：
- 输入：nums = [-7,-3,2,3,11]
- 输出：[4,9,9,49,121]
## 思路
[双指针法经典题目 | LeetCode：977.有序数组的平方_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1QB4y1D7ep/?vd_source=8c3dd385213da0072604192e9b535246)
是非递减顺序的整数数组
解法一：暴力解法，先得到所有元素的平方，在进行排序
	时间复杂度O(nlogn)
解法二：平方后的元素，一定是大的在两端，小的在中间的形式，
	 时间复杂度O(n)
## 暴力解法
```
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
        for (int i = 0; i < A.size(); i++) {
            A[i] *= A[i];
        }
        sort(A.begin(), A.end()); // 快速排序
        return A;
    }
};
```
## 双指针解法
```
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        // 双指针解法
        int left = 0,right = nums.size() - 1;
        int k = nums.size() - 1;
        vector<int> result(nums.size(),0);
        while(left <= right){
            // if(nums[left] * nums[left] < nums[right] * nums[right]){
            //     result[k] = nums[right] * nums[right];
            //     k--;
            //     right--;
            // } else{
            //     result[k] = nums[left] * nums[left];
            //     k--;
            //     left++;
            // }
            if(nums[left] * (-1) < nums[right]) //如果左边是负数，乘-1后与右边比较，如果是正数，则左一定小于右
            {
                result[k] = nums[right] * nums[right];
                k--;
                right--;
            } else{
                result[k] = nums[left] * nums[left];
                k--;
                left++;
            }
        }
        return result;
    }
};
```
# 5.长度最小的子数组
## 题目
[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)
给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。
示例：
- 输入：s = 7, nums = [2,3,1,2,4,3]
- 输出：2
- 解释：子数组 [4,3] 是该条件下的长度最小的子数组。
提示：
- 1 <= target <= 10^9
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^5
## 思路
[拿下滑动窗口！ | LeetCode 209 长度最小的子数组_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1tZ4y1q7XE/?vd_source=8c3dd385213da0072604192e9b535246)
	暴力解法：两层for循环嵌套，即区间起始位置与终止位置，遍历所有情况
	滑动窗口：初始状态下，start 和 end 都指向下标 0，sum 的值为 0。
	每一轮迭代，将 nums[end] 加到 sum，如果 sum≥s，则更新子数组的最小长度（此时子数组的长度是 end−start+1），然后将 nums[start] 从 sum 中减去并将 start 右移，直到 sum<s，在此过程中同样更新子数组的最小长度。在每一轮迭代的最后，将 end 右移。
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)
## 暴力解法
时间复杂度为O(n^2)
```
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        // 暴力求解
        int result = INT_MAX;
        int n = nums.size();
        for(int i = 0;i < n; i++)
        {
            int sum = 0;
            for(int j = i; j < n; j++){
                sum += nums[j];
                if(sum >= target)
                {
                    result = result > (j - i + 1) ? (j - i + 1) : result;
                    break;
                }
            }
        }
        return result == INT_MAX ? 0 : result;
    }
};
```
## 滑动窗口解法
时间复杂度为O(n)
空间复杂度为O(1)
```
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        //滑动窗口
        int n = nums.size();
        int start = 0,end = 0,sum = 0;
        int result = INT_MAX;
        for(;end < n;end++){
            sum += nums[end];
            while(sum >= s){
                result = result > (end - start + 1) ? (end - start + 1) : result;
                sum -= nums[start];
                start++;
            }
        }
        return result == INT_MAX ? 0 : result;
    }
};
```