# 1.二叉树基础

## 相关概念

### 树

**树的定义：** 是n（n>=0）个结点的有限集，n=0时称为空树
	在任意一棵非空树中：
	1. 有且仅有一个根（root）结点
	2. 当n>1时，其余结点可分为m（m>0）个互不相交的有限集，其中每个集合本身又是一棵树。
如图所示：A、B都是树，但C、D有相交的节点，不是树
![500](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250410203958.png)

**树的相关概念：**
	**结点的度：** 结点拥有的字树称为结点的度；
	**叶节点：** 度为0的结点称为叶子结点或者终端结点；
	**树的度：** 树的度是树内各结点的度的最大值；
	**孩子结点：** 结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲
	**兄弟结点：** 同一个双亲的孩子之间互称为兄弟；
	**祖先：** 结点的祖先是从根到该结点所经分支上的所有结点；
	**堂兄弟：** 双亲在同一层的节点互为堂兄弟；
	**子孙：** 以某结点为根的子树中的任一结点都称为该结点的子孙；
	**层次：** 结点的层次从根开始定义起，根为第一层，根的孩子为第二层；
	**树的深度：** 树中结点的走最大层次称为深度；
	**有序树：** 如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树；
	**森林：** 森林是m(m≥0)棵互不相交的树的集合。

### 二叉树

二叉树（Binary Tree）是一种特殊的树
#### 定义：
二叉树是n(n≥0)个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成。
任意一棵二叉树都满足如下条件：
1. 本身是有序树；
2. 树中各个结点的度都不超过2，只能是0或1或2

#### 特点： 
- 每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。注意不是只有两颗子树，而是最多有。没有子树或者有一颗子树都是可以的。
- 左子树和右子树是有顺序的，次序不能颠倒。就像人有双手、双脚。
- 即使树中某结点只有一颗树，也要区分它是左子树还是右子树。

#### 性质：
- **性质1：在二叉树的第i层上最多有2^(i-1)个结点（i≥1）。**
第一层是根结点，只有一个，所以2^(1-1）=2^0=1。 第二层有两个，2^(2-1)=2^1=2。 第三层有四个，2^(3-1)=2^2=4。 第四层有八个，2^(4-1)=2^3=8。
- **性质2：深度为k的二叉树至多有2^k-1个结点（k≥1）。**
注意：是2^k后再减去1，而不是2^(k-1). 深度为k意思就是有k层的二叉树，我们先来看看简单的。 如果有一层，至多1=21-1个结点。 如果有二层，至多1+2=3=22-1个结点。 如果有三层，至多1+2+4=7=23-1个结点。 如果有四层，至多1+2+4+8=15=2^4-1个结点。
- **性质3：对任何一棵二叉树，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1**
终端结点数其实就是叶子结点数，而一棵二叉树，除了叶子结点外，剩下的就是度为1或2的结点数了，我们设n1为度是1的结点数。则树T结点总数n=n0+n1+n2
n = n0 + n1 + n2 （节点数 = 所有节点的个数）
n = 0×n0 + 1×n1 + 2×n2 + 1 （节点数 = 分支数+1）
由这两个公式可以推导出n0 = n2 + 1
- **性质4：具有n个结点的完全二叉树的深度为|log（2^n）+1|  (向下取整)。**
由满二叉树的定义我们可以知道，深度为k的满二叉树的结点数n一定是2^k-1。因为这是最多的结点个数。那么对于n=2^k-1倒推得到满二叉树的深度为k=log2(n＋1)，比如结点数为15的满二叉树，深度为4。
### 满二叉树
如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
![300](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250410211813.png)
这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。

### 完全二叉树

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250410212734.png)
**优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。**

### 二叉搜索树

前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，**二叉搜索树是一个有序树**。
- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树
![image.png](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250411200102.png)

### 平衡二叉搜索树

平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：
它是一棵空树或它的左右两个子树的高度差的**绝对值不超过1**，并且左右两个子树都是一棵平衡二叉树。
![image.png](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250411200150.png)
最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。

**C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。

## 二叉树的存储方式

**二叉树可以链式存储，也可以顺序存储。**

那么链式存储方式就用指针， 顺序存储的方式就是用数组。

### 链式存储
![image.png](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250411201837.png)

### 顺序存储
![image.png](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250411201923.png)

用数组来**存储二叉树**如何遍历的呢？

**如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。**

## 二叉树的遍历方式

二叉树主要有两种遍历方式：
1. 深度优先遍历：先往深走，遇到叶子节点再往回走。
2. 广度优先遍历：一层一层的去遍历。

### 深度优先搜索（Depth First Search，DFS）
- 前序遍历（递归法，迭代法）
- 中序遍历（递归法，迭代法）
- 后序遍历（递归法，迭代法）
**这里前中后，其实指的就是中间节点的遍历顺序**
![image.png](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250411203112.png)
深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。

栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。

### 广度优先搜索（Breadth First Serach，BFS）
- 层次遍历（迭代法）

广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

## 二叉树的代码定义

顺序存储就是用数组

链式存储
```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

# 2.二叉树的递归遍历

## 思路

递归算法的三个要素：
1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
    
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
    
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

以前序遍历为例：
1. 确定函数的参数和返回值：输出前序遍历结点的值，参数中需要传入一个vector用来存放结点数值，不需要再处理其他数据也不需要返回值，所以递归函数返回值是void
```cpp
void traversal(TreeNode * cur, vector<int> &vec)
```
2. 确定终止条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return 
```cpp
if (cur == NULL) return;
```
3. 确定单层递归逻辑：前序遍历是中左右的顺序，所以在单层递归的逻辑，是要先取中节点的数值
```cpp
vec.push_back(cur->val);    // 中
traversal(cur->left, vec);  // 左
traversal(cur->right, vec); // 右
```

## 题目
[144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

[94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

[145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

## 解答
### 前序遍历
```cpp
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        vec.push_back(cur->val);    // 中
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```
### 中序遍历
```cpp
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        traversal(cur->left, vec);  // 左
        vec.push_back(cur->val);    // 中
        traversal(cur->right, vec); // 右
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```
### 后序遍历
```cpp
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
        vec.push_back(cur->val);    // 中
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```
复杂度分析：三种遍历复杂度一致
- 时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。每一个节点恰好被遍历一次。

- 空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。

# 3.二叉树的迭代遍历
## 前序和后序遍历

前序遍历：中左右，每次先遍历的是中结点，先处理的也是中节点，中结点入栈以后弹出，加入结果数组，然后处理中结点的左右结点，先入栈右结点再入栈左节点（这样才是左结点先出栈），然后将栈中最顶端结点设置为新的中结点，以此往复，直到完全遍历二叉树。

后序遍历：左右中，只需要将前序遍历左右结点的处理顺序交换一下，变成中右左，然后将结果翻转即可。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 //前序遍历迭代法
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode *> stk;
        if(!root) return result;
        stk.push(root);
        while(!stk.empty()){
            TreeNode *cur = stk.top();
            stk.pop();
            result.push_back(cur->val);
            if(cur->right) stk.push(cur->right);
            if(cur->left) stk.push(cur->left);
        }
        return result;
    }
};

 //后序遍历迭代法
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode *> stk;
        if(!root) return result;
        stk.push(root);
        while(!stk.empty()){
            TreeNode *cur = stk.top();
            stk.pop();
            result.push_back(cur->val);
            if(cur->left) stk.push(cur->left);
            if(cur->right) stk.push(cur->right);
        }
		reverse(result.begin(),result.end());
        return result;
    }
};
```

## 中序遍历
中序遍历的顺序是左中右，但和前序遍历不同，中序遍历访问的元素和需要处理的元素不是同一个结点，中序遍历需要先访问中间结点，但要先处理的结点确是左结点。

中序遍历的实现需要借助一个指针，栈里依次存放指针遍历过的节点。
指针从根结点开始遍历，如果指针不为空，当前结点入栈，指针更新为当前结点的左结点；如果指针访问的结点的左结点为空，出栈；指针结点更新为栈的顶部结点并出栈，再查看此时指针结点的右结点，如不为空，入栈；指针更新为栈的顶部结点并出栈

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        TreeNode *cur = root;
        vector<int> result;
        stack<TreeNode *> stk;
        while(cur != nullptr || !stk.empty()){//先判断cur是否为空
            if(cur != nullptr){
                stk.push(cur);
                cur = cur->left;   //遍历到最左结点之后，cur为空，但此时栈不空，循环继续
            }else{
                cur = stk.top();   //将cur指针指向栈最顶端结点
                stk.pop();
                result.push_back(cur->val); //中
                cur = cur->right;           //然后遍历右结点，进入下一次循环，如cur->right不为空，则在下一次循环入栈。
            }
        }
        return result;
    }
};
```

# 4.二叉树的统一迭代
## 题目
[144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

[94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

[145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)
## 空指针标记法

将要处理的节点放入栈之后，再放入一个空指针，这样，识别到空指针之后，将空指针弹出，再将要处理的节点放入结果集中
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
//前序遍历
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode *> stk;
        if(root) stk.push(root);
        while(!stk.empty()){
            TreeNode *cur = stk.top();
            if(cur){
                stk.pop();
                if(cur->right) stk.push(cur->right);
                if(cur->left) stk.push(cur->left);
                stk.push(cur);
                stk.push(nullptr);
            }else{
                stk.pop();
                cur = stk.top();
                stk.pop();
                result.push_back(cur->val);
            }
        }
        return result;
    }
};
 //中序遍历
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> stk;
        if(root) stk.push(root);
        while(!stk.empty()){
            TreeNode *cur = stk.top();
            if(cur){
                stk.pop(); //先将当前节点弹出，然后按照右中左的顺序入栈
                if(cur->right) stk.push(cur->right);
                stk.push(cur);
                stk.push(nullptr);
                if(cur->left) stk.push(cur->left);
            }else{
                stk.pop();  // 弹出空指针
                cur = stk.top();
                stk.pop();
                result.push_back(cur->val);
            }
        }
        return result;
    }
};

//后序遍历
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode *> stk;
        if(root) stk.push(root);
        while(!stk.empty()){
            TreeNode *cur = stk.top();
            if(cur){
                stk.pop();
                stk.push(cur);          //为了统一代码规范
                stk.push(nullptr);

                if(cur->right) stk.push(cur->right);
                if(cur->left) stk.push(cur->left);
            }else{
                stk.pop();
                cur = stk.top();
                stk.pop();
                result.push_back(cur->val);
            } 
        }
        return result;
    }
};
```
## boolean标记法
**加一个 `boolean` 值跟随每个节点，`false` (默认值) 表示需要为该节点和它的左右儿子安排在栈中的位次，`true` 表示该节点的位次之前已经安排过了，可以收割节点了。**

```cpp
//中序遍历
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<pair<TreeNode*, bool>> st;
        if (root != nullptr)
            st.push(make_pair(root, false)); // 多加一个参数，false 为默认值，含义见下文注释

        while (!st.empty()) {
            auto node = st.top().first;
            auto visited = st.top().second; //多加一个 visited 参数，使“迭代统一写法”成为一件简单的事
            st.pop();

            if (visited) { // visited 为 True，表示该节点和两个儿子位次之前已经安排过了，现在可以收割节点了
                result.push_back(node->val);
                continue;
            }

            // visited 当前为 false, 表示初次访问本节点，此次访问的目的是“把自己和两个儿子在栈中安排好位次”。
            
            // 中序遍历是'左中右'，右儿子最先入栈，最后出栈。
            if (node->right)
                st.push(make_pair(node->right, false));
            
            // 把自己加回到栈中，位置居中。
            // 同时，设置 visited 为 true，表示下次再访问本节点时，允许收割。
            st.push(make_pair(node, true));

            if (node->left)
                st.push(make_pair(node->left, false)); // 左儿子最后入栈，最先出栈
        }
        
        return result;
    }
};

//后序遍历
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<pair<TreeNode*, bool>> st;
        if (root != nullptr)
            st.push(make_pair(root, false)); // 多加一个参数，false 为默认值，含义见下文

        while (!st.empty()) {
            auto node = st.top().first;
            auto visited = st.top().second; //多加一个 visited 参数，使“迭代统一写法”成为一件简单的事
            st.pop();

            if (visited) { // visited 为 True，表示该节点和两个儿子位次之前已经安排过了，现在可以收割节点了
                result.push_back(node->val);
                continue;
            }

            // visited 当前为 false, 表示初次访问本节点，此次访问的目的是“把自己和两个儿子在栈中安排好位次”。
            // 后序遍历是'左右中'，节点自己最先入栈，最后出栈。
            // 同时，设置 visited 为 true，表示下次再访问本节点时，允许收割。
            st.push(make_pair(node, true));

            if (node->right)
                st.push(make_pair(node->right, false)); // 右儿子位置居中

            if (node->left)
                st.push(make_pair(node->left, false)); // 左儿子最后入栈，最先出栈
        }
        
        return result;
    }
};
```
# 5.二叉树的层序遍历

## 题目
[102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)
给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

**输入：** root = [3,9,20,null,null,15,7]
**输出：** [ [3],[9,20],[15,7] ]

**示例 2：**

**输入：** root = [1]
**输出：** [ [1] ]

**示例 3：**

**输入：** root = []
**输出：** []

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`

## 思路
层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。

需要借用一个辅助数据结构即队列来实现，**队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。**

**而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。**

使用队列实现二叉树广度优先遍历，动画如下：

![102二叉树的层序遍历](https://code-thinking.cdn.bcebos.com/gifs/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif)

## 代码
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        queue<TreeNode *> que;
        if(root) que.push(root);
        while(que.size()){
            vector<int> vec;
            int size = que.size();
            for(int i = 0; i < size; i++){
                TreeNode *cur = que.front();
                que.pop();
                vec.push_back(cur->val);
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

## 层序遍历其他题目

### 107.二叉树的层序遍历II（Medium）
[107. 二叉树的层序遍历 II - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/)

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

![107.二叉树的层次遍历II|400](https://file.kamacoder.com/pics/20210203151058308.png)
只需将层序遍历[102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)结果翻转输出即可            
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> result;
        queue<TreeNode *> que;
        if(root) que.push(root);
        while(que.size()){
            int size = que.size();
            vector<int> vec;
            for(int i = 0; i < size; i++){
                TreeNode *cur = que.front();
                que.pop();
                vec.push_back(cur->val);
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
            result.push_back(vec);
        }
        reverse(result.begin(),result.end());
        return result;
    }
};
```

### 199.二叉树的右视图（Medium）
[199. 二叉树的右视图 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-right-side-view/description/)
给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

![199.二叉树的右视图|275](https://file.kamacoder.com/pics/20210203151307377.png)

在遍历的基础上加上一个判断条件，只有当遍历到每一行末尾时才将数值加入结果数组
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> result;
        queue<TreeNode *> que;
        if(root) que.push(root);
        while(que.size()){
            int size = que.size();
            while(size){
                TreeNode *cur = que.front();
                que.pop();
                if(size == 1) result.push_back(cur->val);
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
                size--;
             }
        }
        return result;
    }
};
```

### 637.二叉树的层平均值（Medium）
[637. 二叉树的层平均值 - 力扣（LeetCode）](https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/)
给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。

![637.二叉树的层平均值](https://file.kamacoder.com/pics/20210203151350500.png)

遍历过程中求和，遍历完每层之后求平均值，再加入结果集
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> result;
        queue<TreeNode *> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            double sum = 0;
            for(int i = 0; i < size; i++){
                TreeNode *cur = que.front();
                que.pop();
                sum += cur->val;
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
            result.push_back(sum / size);
        }
        return result; 
    }
};
```

### 429.N叉树的层序遍历（Mediym）
[429. N 叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/)

给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。

例如，给定一个 3叉树 :

![429. N叉树的层序遍历|300](https://file.kamacoder.com/pics/20210203151439168.png)

返回其层序遍历:

[ [1], [3,2,4], [5,6] ]

二叉树层序遍历的变种而已，只需要注意孩子结点的处理即可

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> result;
        queue<Node*> que;
        if(root) que.push(root);
        while(!que.empty()){
            vector<int> vec;
            int size = que.size();
            while(size--){
                Node *cur = que.front();
                que.pop();
                vec.push_back(cur->val);
                for(int i = 0; i < cur->children.size(); i++)
                    if(cur->children[i]) que.push(cur->children[i]);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```
### 515.在每个树行中找最大值（Medium）
[515. 在每个树行中找最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/)

层序遍历，记录最大值即可

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        vector<int> result;
        queue<TreeNode *> que;
        if(root) que.push(root);
        while(que.size()){
            int max = INT_MIN;
            int size = que.size();
            while(size--){
                TreeNode *cur= que.front();
                que.pop();
                max = max > cur->val ? max : cur->val;
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
            result.push_back(max);
        }
        return result;
    }
};
```

### 116.填充每个节点的下一个右侧节点指针（Medium）
[116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/)

给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

![116.填充每个节点的下一个右侧节点指针](https://file.kamacoder.com/pics/20210203152044855.jpg)

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        queue<Node *> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            Node *cur;
            Node *pre;
            for(int i = 0; i < size; i++){
                cur = que.front();
                que.pop();
                if(i < size - 1)
                    cur->next = que.front();

                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
        }
        return root;
    }
};
```

### 117.填充每个节点的下一个右侧节点指针II（Medium）
[117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/)
和116一致的解法
```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        queue<Node *> que;
        if(root) que.push(root);
        while(!que.empty()){
            int size = que.size();
            while(size--){
                Node *cur = que.front();
                que.pop();
                if(size > 0)
                    cur->next = que.front();
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
        }
        return root;
    }
};
```
### 104.二叉树的最大深度（Easy）
[104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：

给定二叉树 [3,9,20,null,null,15,7]，

![104. 二叉树的最大深度](https://file.kamacoder.com/pics/20210203153031914-20230310134849764.png)

返回它的最大深度 3 。

层序遍历的层数即是树的最大深度
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        queue<TreeNode *> que;
        int depth = 0;
        que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth+=1;
            while(size--){
                TreeNode *cur = que.front();
                que.pop();
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
        }
        return depth;
    }
};
```

### 111.二叉树的最小深度（Easy）
[111. 二叉树的最小深度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)

层序遍历，在二叉树的最大深度基础上加上中断，当左右结点都为空时，说明是最小深度了
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        queue<TreeNode *> que;
        int depth = 0;
        que.push(root);
        while(!que.empty()){
            int size = que.size();
            depth ++;
            while(size--){
                TreeNode *cur = que.front();
                que.pop();
                if(!cur->left && !cur->right) return depth;
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
        }
        return depth;
    }
};
```

# 6.翻转二叉树（226，Easy）
## 题目
[226. 翻转二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/invert-binary-tree/)
翻转一棵二叉树。

![226.翻转二叉树|425](https://file.kamacoder.com/pics/20210203192644329.png)

## 思路

翻转左子树与右子树，然后递归即可，可以用前序遍历或者后序遍历

## 解法
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 //递归前序遍历
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) return root;
        swap(root->left,root->right);
        invertTree(root->left);
        invertTree(root->right);

        return root;
    }
};

// 统一迭代前序遍历
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode *> stk;
        if(root) stk.push(root);
        while(!stk.empty()){
            TreeNode *cur = stk.top();
            stk.pop();
            if(cur){
                if(cur->right) stk.push(cur->right);
                if(cur->left) stk.push(cur->left);
                stk.push(cur);
                stk.push(nullptr);
            }else{
                cur = stk.top();
                stk.pop();
                swap(cur->left,cur->right);
            }
        }
        return root;
    }
};

//层序遍历
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return root;
        queue<TreeNode *> que;
        que.push(root);
        while(!que.empty()){
            int size = que.size();
            while(size--){
                TreeNode *cur = que.front();
                que.pop();
                swap(cur->left,cur->right);
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
        }
        return root;
    }
};
```

# 7.对称二叉树

## 题目
[101. 对称二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/symmetric-tree/submissions/623749338/)
给定一个二叉树，检查它是否是镜像对称的。

![101. 对称二叉树](https://file.kamacoder.com/pics/20210203144607387.png)

## 思路
比较左子树的左结点与右子树的右结点，比较左子树的右结点与右子树的左结点

**递归法**

本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。

**正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。**

递归三部曲

1. 确定递归函数的参数和返回值

因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。

返回值自然是bool类型。

代码如下：

```
bool compare(TreeNode* left, TreeNode* right)
```

2. 确定终止条件

要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。

节点为空的情况有：（**注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点**）

- 左节点为空，右节点不为空，不对称，return false
- 左不为空，右为空，不对称 return false
- 左右都为空，对称，返回true

此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：

- 左右都不为空，比较节点数值，不相同就return false

此时左右节点不为空，且数值也不相同的情况我们也处理了。

代码如下：

```
if (left == NULL && right != NULL) return false;
else if (left != NULL && right == NULL) return false;
else if (left == NULL && right == NULL) return true;
else if (left->val != right->val) return false; // 注意这里我没有使用else
```

注意上面最后一种情况，我没有使用else，而是else if， 因为我们把以上情况都排除之后，剩下的就是 左右节点都不为空，且数值相同的情况。

3. 确定单层递归的逻辑

此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。

- 比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。
- 比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。
- 如果左右都对称就返回true ，有一侧不对称就返回false 。

代码如下：

```
bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
bool isSame = outside && inside;                    // 左子树：中、 右子树：中（逻辑处理）
return isSame;
```

如上代码中，我们可以看出使用的遍历方式，左子树左右中，右子树右左中，所以我把这个遍历顺序也称之为“后序遍历”（尽管不是严格的后序遍历）。


**迭代法**

这道题目我们也可以使用迭代法，但要注意，这里的迭代法可不是前中后序的迭代写法，因为本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓二叉树遍历的前中后序的关系了。

这里我们可以使用队列来比较两个树（根节点的左右子树）是否相互翻转，（**注意这不是层序遍历**）

使用队列或栈，情况是一致的

通过队列来判断根节点的左子树和右子树的内侧和外侧是否相等，如动画所示：

![101.对称二叉树](https://code-thinking.cdn.bcebos.com/gifs/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.gif)

如下的条件判断和递归的逻辑是一样的。
## 代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 //递归
class Solution {
public:
    bool compare(TreeNode *left,TreeNode *right){
        if(!left && !right) return true; //left与right都为空
        if(!left || !right) return false;//left与right中不都为空，因为都为空的情况已经在上一步排除
        if(left->val != right->val) return false;
        //进行到这就是左右节点都不为空且val相等的情况
        //比较left的左结点与right的右结点
        //比较left的右结点与right的左结点
        return compare(left->left,right->right) && compare(left->right,right->left);
    }
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return compare(root->left,root->right);
    }
};

//迭代
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        
        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};

```

# 8.二叉树数的最大深度

## 题目
[104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

## 解法
广度优先搜索（层序遍历解法）
[[07-二叉树#5.二叉树的层序遍历#104.二叉树的最大深度（Easy）]]

深度优先搜索（递归法）

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int getDepth(TreeNode *cur){
        if(!cur) return 0;
        int leftDepth = getDepth(cur->left);
        int rightDepth = getDepth(cur->right);
        return 1 + max(leftDepth,rightDepth);
    }
    int maxDepth(TreeNode* root) {
        return getDepth(root);
    }
};
 //精简代码
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        return 1 + max(maxDepth(root->left),maxDepth(root->right)); 
    }
};
```
# 9.二叉树的最小深度

## 题目
[111. 二叉树的最小深度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

## 代码
广度优先搜索（层序遍历）
[[07-二叉树#5.二叉树的层序遍历#111.二叉树的最小深度（Easy）]]

深度优先搜索（递归）
与[[#8.二叉树数的最大深度]]的不同在于处理左右子树不为空的逻辑
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;

        if(!root->left && !root->right) return 1;
        int mindepth = INT_MAX;
        if(root->left){
            mindepth = min(minDepth(root->left),mindepth);
        }

        if(root->right){
            mindepth = min(minDepth(root->right),mindepth);
        }

        return 1 + mindepth; //加1是需要算上中间节点
    }
};
```

# 10.完全二叉树的节点个数

## 题目
[222. 完全二叉树的节点个数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-complete-tree-nodes/)

## 思路
深度优先搜索：递归法
1. 确定参数：cur
2. 递归结束条件：cur为空
3. 单层递归逻辑：先求左子树的节点数量再求右子树的节点数量，取总和加1（加1是算上当前结点）
广度优先搜索：层序遍历后统计个数即可

## 代码
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(!root) return 0;
        int left_node = countNodes(root->left);
        int right_node = countNodes(root->right);
        int sum_node = left_node + right_node + 1;
        return sum_node;
    }
};

//精简版本
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(!root) return 0;
        return 1 + countNodes(root->left) + countNodes(root->right);
    }
};

//层序遍历
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(!root) return 0;
        queue<TreeNode *> que;
        que.push(root);
        int result = 0;
        while(!que.empty()){
            int size = que.size();
            while(size--){
                TreeNode *cur = que.front();
                que.pop();
                result++;
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
        }
        return result;
    }
};
```

# 11.平衡二叉树
## 题目
[110. 平衡二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/balanced-binary-tree/description/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

![110.平衡二叉树](https://file.kamacoder.com/pics/2021020315542230.png)

返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

![110.平衡二叉树1](https://file.kamacoder.com/pics/20210203155447919.png)

返回 false

## 思路
二叉树的高度和深度是不同的概念

- 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

但leetcode中强调的深度和高度很明显是按照节点来计算的，如图：

![110.平衡二叉树2](https://file.kamacoder.com/pics/20210203155515650.png)

**因为求深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）**

在[[#8.二叉树数的最大深度]]中代码本质是求根节点的高度，根节点的高度就是这棵树的最大深度

**递归法：**
1. 递归函数的参数和返回值：
	参数：当前转入节点，
	返回值：以当前传入节点为根节点的树的高度
2. 结束条件：
	遇到空节点终止，返回0，表示当前节点为根节点的树的高度为0
3. 单层递归逻辑：
	分别求出当前节点左右子树的高度，判断差值是否大于1，若大于1，说明已经不是平衡二叉树了，返回-1，否则，返回当前二叉树的高度。

**迭代法：** 但还是别迭代了
可定义一个函数专门用来求高度
结点的高度就是结点的最大深度
顺序需要使用后序遍历（左右中）


## 代码
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 //递归法
class Solution {
public:
    int getHeight(TreeNode *cur){
        if(!cur) return 0;
        
        int left_height = getHeight(cur->left);
        if(left_height == -1) return -1;
        int right_height = getHeight(cur->right);
        if(right_height == -1) return -1;
        
        if(abs(left_height-right_height) > 1) return -1;
        else return 1 + max(left_height,right_height);
    }
    bool isBalanced(TreeNode* root) {
        return getHeight(root) == -1 ? false : true;
    }
};

//迭代法 还是别迭代了
class Solution {
public:
    int getHeight(TreeNode *root){
        if(!root) return 0;
        int depth = 0; 
        int result = 0;
        stack<TreeNode *> stk;
        stk.push(root);
        while(!stk.empty()){
            TreeNode *cur = stk.top();
            stk.pop();
            if(cur){
                stk.push(cur);
                stk.push(nullptr);
                depth++;
                if(cur->right) stk.push(cur->right);
                if(cur->left) stk.push(cur->left);
            }else{
                stk.pop();
                depth--;
            }
            result = result > depth ? result : depth; //记录最大深度
        }
        return result;
    }
    bool isBalanced(TreeNode* root) {
        if(!root) return true;
        stack<TreeNode *> stk;
        stk.push(root);
        while(!stk.empty()){
            TreeNode *cur = stk.top();
            stk.pop();
            if(abs(getHeight(cur->left) - getHeight(cur->right)) > 1)
                return false;
            
            
            if(cur->left) stk.push(cur->left);
            if(cur->right) stk.push(cur->right);
        }
        return true;
    }
};

```

# 12.二叉树的所有路径

## 题目
 [257. 二叉树的所有路径 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-paths/)
给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。

示例: ![257.二叉树的所有路径1](https://file.kamacoder.com/pics/2021020415161576.png)

## 思路
递归+回溯
在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一个路径再进入另一个路径。

## 代码
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void traverse(TreeNode *cur,vector<int> &path,vector<string> &result){
        path.push_back(cur->val);
        if(cur->left == nullptr && cur->right == nullptr){//找到了叶子结点
            string spath;
            for(int i = 0; i < path.size() - 1; i++){
                spath += to_string(path[i]);
                spath += "->";
            }
            spath += to_string(path[path.size() - 1]); //最后一个节点
            result.push_back(spath);
        }

        if(cur->left){
            traverse(cur->left,path,result);
            path.pop_back();//回溯到上一个节点
        }

        if(cur->right){
            traverse(cur->right,path,result);
            path.pop_back();//回溯到上一个节点
        }
            
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        vector<int> path;
        traverse(root,path,result);
        return result;
    }
};
```