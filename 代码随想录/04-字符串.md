# 1.反转字符串（344，Easy）
## 题目
[344. 反转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string/)
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 1：  
输入：["h","e","l","l","o"]  
输出：["o","l","l","e","h"]

示例 2：  
输入：["H","a","n","n","a","h"]  
输出：["h","a","n","n","a","H"]

## 思路

双指针，头尾交换元素即可

## 解法
```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
        int len = s.size();
        for(int i = 0,j = len - 1;i < len/2; i++,j--){
            // int temp = s[i];
            // s[i] = s[j];
            // s[j] = temp;
            swap(s[i],s[j]);
        }
        //reverse(s.begin(),s.end());//库函数reverse();
    }
};
```
# 2.反转字符串II（541，Easy）
## 题目
[541. 反转字符串 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string-ii/description/)
给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。

如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

示例:

输入: s = "abcdefg", k = 2  
输出: "bacdfeg"

## 思路
和[[#1.反转字符串]]一致，按规则翻转即可

## 解法
```cpp
class Solution {
public:
    string reverseStr(string s, int k) {
        int len = s.size();
        for(int i = 0;i < len; i += (2 * k)){
            if(i + k > len){ // 剩余字符少于k个
                for(int l = 0,m = len - i - 1;l < m; l++,m--){
                    int temp = s[l + i];
                    s[l + i] = s[m + i];
                    s[m + i] = temp;
                }
                // reverse(s.begin() + i,s.end());
            }
            else{ // 剩余字符少于2k个以及其他情况处理逻辑一致
                for(int l = 0,m = k - 1;l < m; l++,m--){
                    int temp = s[l + i];
                    s[l + i] = s[m + i];
                    s[m + i] = temp;
                }
                // reverse(s.begin() + i, s.begin() + i + k);
            }
        }
        return s;
    }
};
```
# 3.替换数字
## 题目
[54. 替换数字（第八期模拟笔试）](https://kamacoder.com/problempage.php?pid=1064)
给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。

例如，对于输入字符串 "a1b2c3"，函数应该将其转换为 "anumberbnumbercnumber"。

对于输入字符串 "a5b"，函数应该将其转换为 "anumberb"

输入：一个字符串 s,s 仅包含小写字母和数字字符。

输出：打印一个新的字符串，其中每个数字字符都被替换为了number

样例输入：a1b2c3

样例输出：anumberbnumbercnumber

数据范围：1 <= s.length < 10000。

## 思路
先扩充字符串大小
然后从后向前重新填充数组

**其实很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

这么做有两个好处：

1. 不用申请新数组。
2. 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/54%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.png)
## 解法
```cpp
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s;
    cin >> s;
    int OldIndex = s.size() - 1;
    int count = 0;//记录数字字符数量
    for(int i = 0; i <= OldIndex; i++){
        if(s[i] >= '0' && s[i] <= '9')
            count++;
    }
    s.resize(s.size() + count * 5);
    int NewIndex = s.size() - 1;
    while(OldIndex >= 0){
        if(s[OldIndex] >= '0' && s[OldIndex] <= '9'){
            s[NewIndex--] = 'r';
            s[NewIndex--] = 'e';
            s[NewIndex--] = 'b';
            s[NewIndex--] = 'm';
            s[NewIndex--] = 'u';
            s[NewIndex--] = 'n';
        }else
            s[NewIndex--] = s[OldIndex];
        OldIndex--;
    }
    cout << s << endl;
}
```
# 4.翻转字符串里的单词
## 题目
[151. 反转字符串中的单词 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string/description/)
给定一个字符串，逐个翻转字符串中的每个单词。

示例 1：  
输入: "the sky is blue"  
输出: "blue is sky the"

示例 2：  
输入: "  hello world!  "  
输出: "world! hello"  
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

示例 3：  
输入: "a good   example"  
输出: "example good a"  
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

## 思路
1. 字符串操作
	- 首先删除字符串里多余的空格
	-  翻转整个字符串
	-  逐个翻转单词
2. 栈
	- 先入后出

## 解法
```cpp
class Solution {
public:
    //移除字符串中多余的空格
    void removeExSpace(string &s){
        int slow = 0, fast = 0;
        //删除最前面的空格
        while(s.size() > 0 && fast < s.size() && s[fast] == ' ')
            fast++;
        for(;fast < s.size(); fast++){
            if(s[fast] != ' ')
                s[slow++] = s[fast];
            if(s[fast] == ' ' && s[fast + 1] != ' ')
                s[slow++] = ' ';
        }
        //删除最后的空格（如果有）
        if(slow > 0 && s[slow - 1] == ' ') s.resize(slow - 1);
        else s.resize(slow);
    }
    //翻转字符串,[left,right]
    void reverseString(string &s,int left,int right){
        for(;left < right;left++,right--){
            swap(s[left],s[right]);
        }
    }
    string reverseWords(string s) {
        //删除多余空格
        removeExSpace(s);
        //翻转整个字符串
        reverseString(s,0,s.size() - 1);
        int start = 0;
        int i = 0;
        for(; i < s.size(); i++){
            if(s[i] == ' '){
                reverseString(s,start,i - 1);
                start = i + 1;
            }  
        }
        //翻转最后一个单词
        reverseString(s,start,i - 1);
        return s;
    }
};
```