# 1.链表基础
## 定义
	链表是一种通过指针串联在一起的线性结构，每一个节点由两个部分组成，一个是数据域，另一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向NULL（空指针）。
	链表的入口节点称为链表的头结点也就是head。
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250324140244.png)
## 链表的类型
- 单链表
定义即为单链表。
- 双链表
	单链表中的指针域只指向节点的下一个节点。
	双链表：每一个节点有两个指针域，一个指向下一个节点，另一个指向上一个节点。
	因而双链表既可以向前查询，也可以向后查询。
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250324141006.png)
- 循环链表
	即链表首尾相连。
	循环链表可以用来解决约瑟夫环问题。
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250324141123.png)
## 链表的存储方式
	数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。
	链表是通过指针域的指针链接在内存中的各个节点。
## 链表节点的定义
	构造函数
```
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```
	另外，C++默认会生成一个构造函数，但这个构造函数不会初始化任何成员变量
	通过自己定义构造函数初始化节点：

```
ListNode* head = new ListNode(5);
```
	使用默认构造函数初始化节点：
```
ListNode* head = new ListNode();
head->val = 5;
```
	所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！
## 链表的操作
### 删除节点
删除D节点
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250324142142.png)
只需要将C节点的next指针指向E节点就可以了，
但D节点仍存在内存中，因而在C++中最好需要手动释放D节点，释放这块内存，
Java和Python有自动的内存回收机制，不需要手动释放。
### 添加节点
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250324142438.png)
添加F节点
## 链表性能分析
链表的删除和增加操作时间复杂度都是O(1)，也不会影响其他节点
但是，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。

|     | 插入/删除（时间复杂度） | 查询（时间复杂度） |       适用场景       |
| :-: | :----------: | :-------: | :--------------: |
| 数组  |     O(n)     |   O(1)    | 数据量固定，频繁查询，较少增删  |
| 链表  |     O(1)     |   O(n)    | 数据量不固定，频繁增删，较少查询 |
数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。
链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。
# 2.移除链表元素
## 题目
[203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)
题意：删除链表中等于给定值 val 的所有节点。
示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]
示例 2： 输入：head = [], val = 1 输出：[]
示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]
## 思路
[手把手带你学会操作链表 | LeetCode：203.移除链表元素_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV18B4y1s7R9/?vd_source=8c3dd385213da0072604192e9b535246)
- 使用原链表删除，只需让节点next指针直接指向下下一个节点就可以，但是需要注意手动清除内存，注意，头结点的删除，只需将head指针后移一位。
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250324144108.png)
头节点的移除
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250324144154.png)
- 使用虚拟头结点，就可以按照统一的逻辑进行操作
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250324144253.png)
## 解法
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        // //解法一：使用原链表进行删除
        // //删除头结点
        // while(head != nullptr && head->val == val){
        //     ListNode  *tem = head;
        //     head = head->next;
        //     delete tem;
        // }
        // //删除其他节点
        // ListNode *tem = head;
        // while(tem != nullptr && tem->next != nullptr){
        //     if(tem->next->val == val){
        //         ListNode *tem2 = tem->next;
        //         tem->next = tem->next->next;
        //         delete tem2;
        //     }else{
        //         tem = tem->next;
        //     }
        // }
        // return head;
        //==============================================
        // 解法二：使用虚拟头节点
        ListNode *dummyHead = new ListNode(val - 1); //虚拟节点的val设置为不等val的值
        dummyHead->next = head;
        ListNode *cur = dummyHead;
        while(cur->next != nullptr){
            if(cur->next->val == val){
                ListNode *tem = cur->next;
                cur->next = cur->next->next;
                delete tem;
            }
            else{
                cur = cur->next;
            }
        }
        head = dummyHead->next;
        delete dummyHead;
        return head;
    }
};
```
- 时间复杂度O(n)
- 空间复杂度O(1)
# 3.设计链表
## 题目
[707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/description/)
题意：
你可以选择使用单链表或者双链表，设计并实现自己的链表。
单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。
如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。
实现 `MyLinkedList` 类：
- `MyLinkedList()` 初始化 `MyLinkedList` 对象。
- `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 
- `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
- `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
- `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
- `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。
**示例：**
**输入**
["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
[ [], [1], [3], [1, 2], [1], [1], [1] ]
**输出**
[null, null, null, null, 2, null, 3]

**解释**
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // 链表变为 1->2->3
myLinkedList.get(1);              // 返回 2
myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1->3
myLinkedList.get(1);              // 返回 3

**提示：**
- `0 <= index, val <= 1000`
- 请不要使用内置的 LinkedList 库。
- 调用 `get`、`addAtHead`、`addAtTail`、`addAtIndex` 和 `deleteAtIndex` 的次数不超过 `2000` 。

## 思路
[帮你把链表操作学个通透！LeetCode：707.设计链表_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1FU4y1X7WD/?vd_source=8c3dd385213da0072604192e9b535246)
## 解答-单链表
```
class MyLinkedList {
public:
    // 定义链表节点结构体
    struct LinkedNode {
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val), next(nullptr){}
    };

    // 初始化链表
    MyLinkedList() {
        _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点
        _size = 0;
    }

    // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点
    int get(int index) {
        if (index > (_size - 1) || index < 0) {
            return -1;
        }
        LinkedNode* cur = _dummyHead->next;
        while(index--){ // 如果--index 就会陷入死循环
            cur = cur->next;
        }
        return cur->val;
    }

    // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点
    void addAtHead(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next = _dummyHead->next;
        _dummyHead->next = newNode;
        _size++;
    }

    // 在链表最后面添加一个节点
    void addAtTail(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(cur->next != nullptr){
            cur = cur->next;
        }
        cur->next = newNode;
        _size++;
    }

    // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
    // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点
    // 如果index大于链表的长度，则返回空
    // 如果index小于0，则在头部插入节点
    void addAtIndex(int index, int val) {
        if(index > _size) return;
        if(index < 0) index = 0;        
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur->next;
        }
        newNode->next = cur->next;
        cur->next = newNode;
        _size++;
    }

    // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的
    void deleteAtIndex(int index) {
        if (index >= _size || index < 0) {
            return;
        }
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur ->next;
        }
        LinkedNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        //delete命令指示释放了tmp指针原本所指的那部分内存，
        //被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，
        //如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针
        //如果之后的程序不小心使用了tmp，会指向难以预想的内存空间
        tmp=nullptr;
        _size--;
    }

    // 打印链表
    void printLinkedList() {
        LinkedNode* cur = _dummyHead;
        while (cur->next != nullptr) {
            cout << cur->next->val << " ";
            cur = cur->next;
        }
        cout << endl;
    }
private:
    int _size;
    LinkedNode* _dummyHead;
};
```
- 时间复杂度: 涉及 `index` 的相关操作为 O(index), 其余为 O(1)
- 空间复杂度: O(n)
## 解答-双链表
```
class MyLinkedList {
public:
    // 定义双链表节点
    struct dLinkNode {
        int val;
        dLinkNode* prev;
        dLinkNode* next;
        dLinkNode(int x) : val(x), prev(nullptr), next(nullptr) {}; // 构造函数
    };
    
    MyLinkedList() {
        size = 0;
        dummyHead = new dLinkNode(0); // 创建虚拟头结点
        dummyHead->next = dummyHead;
        dummyHead->prev = dummyHead;
    }

    int get(int index) {
        if (index < 0 || index >= size)
            return -1;
        dLinkNode* curNode = dummyHead;
        if (index + 1 > size - index) { // 从后往前遍历
            for (int i = 0; i < size - index; i++)
                curNode = curNode->prev;
        } else { // 从前往后遍历
            for (int i = 0; i < index + 1; i++)
                curNode = curNode->next;
        }
        return curNode->val;
    }

    void addAtHead(int val) {
        dLinkNode* newNode = new dLinkNode(val);
        newNode->prev = dummyHead;
        dummyHead->next->prev = newNode;
        newNode->next = dummyHead->next;
        dummyHead->next = newNode;
        size++;
    }
    
    void addAtTail(int val) {
        dLinkNode* newNode = new dLinkNode(val);
        newNode->next = dummyHead;
        dummyHead->prev->next = newNode;
        newNode->prev = dummyHead->prev;
        dummyHead->prev = newNode;
        size++;
    }

    void addAtIndex(int index, int val) {
        if (index > size)
            return;
        if (index < 0)
            index = 0;
        dLinkNode* curNode = dummyHead;
        dLinkNode* newNode = new dLinkNode(val);
        if (index + 1 > size - index) { // 则从后往前遍历
            for (int i = 0; i < size - index;
                 i++) { // 移动到index节点的后一个节点
                curNode = curNode->prev;
            }
            newNode->prev = curNode->prev;
            curNode->prev->next = newNode;
            curNode->prev = newNode;
            newNode->next = curNode;
        } else {                              // 从前往后遍历
            for (int i = 0; i < index; i++) { // 移动到index节点的前一个节点
                curNode = curNode->next;
            }
            newNode->next = curNode->next;
            curNode->next->prev = newNode;
            curNode->next = newNode;
            newNode->prev = curNode;
        }
        size++;
    }

    void deleteAtIndex(int index) {
        if (index < 0 || index >= size)
            return;
        dLinkNode* curNode = dummyHead;
        // 寻找到index节点
        if (index + 1 > size - index) { // 从后往前遍历
            for (int i = 0; i < size - index; i++)
                curNode = curNode->prev;
        } else { // 从前往后遍历
            for (int i = 0; i < index + 1; i++)
                curNode = curNode->next;
        }
        dLinkNode* tem = curNode;
        curNode->prev->next = curNode->next;
        curNode->next->prev = curNode->prev;
        delete tem;
        size--;
    }
    
private:
    int size;
    dLinkNode* dummyHead;
};
/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```
# 4.翻转链表
## 题目
[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/)
题意：反转一个单链表。
示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL
## 思路
[帮你拿下反转链表 | LeetCode：206.反转链表 | 双指针法 | 递归法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1nB4y1i7eL/?vd_source=8c3dd385213da0072604192e9b535246)
不需要创建一个新的链表，只需使用两个指针即可
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif)

## 解答-双指针法
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *curNode = head;
        ListNode *preNode = nullptr;
        ListNode *tem;
        while(curNode != nullptr){
            tem = curNode->next;
            curNode->next = preNode;
            preNode = curNode;
            curNode = tem;
        }
        return preNode;
    }
};
```
- 时间复杂度O(n)
- 空间复杂度O(1)
# 5.两两交换链表中的节点
## 题目
[24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)
给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
**示例 1：**
输入：head = [1,2,3,4]
输出：[2,1,4,3]

**示例 2：**
输入：head = []
输出：[]

**示例 3：**
输入：head = [1]
输出：[1]

**提示：**
- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`
## 思路
[帮你把链表细节学清楚！ | LeetCode：24. 两两交换链表中的节点_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1YT411g7br/?vd_source=8c3dd385213da0072604192e9b535246)
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250325204435.png)
## 解答
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode *dummyHead = new ListNode();
        dummyHead->next = head;
        ListNode *curNode = dummyHead;
        while(curNode->next != nullptr && curNode->next->next != nullptr)
        {
            ListNode *tem = curNode->next;//临时节点记录需要交换的第一个节点位置
            curNode->next = tem->next; //步骤一，curNode指向交换的第二个节点位置
            tem->next = tem->next->next; //步骤二，第一个节点指向第二节点的下一个节点
            curNode->next->next = tem;  //步骤三，第二个节点指向第一个节点

            curNode = curNode->next->next; // curNode指向下一组需要交换的节点的前一个节点
        }
        head = dummyHead->next;
        delete dummyHead;
        return head;
    }
};
```
- 时间复杂度O(n)
- 空间复杂度O(1)