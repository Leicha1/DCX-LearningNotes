# 1.链表基础
## 定义
	链表是一种通过指针串联在一起的线性结构，每一个节点由两个部分组成，一个是数据域，另一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向NULL（空指针）。
	链表的入口节点称为链表的头结点也就是head。
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250324140244.png)
## 链表的类型
- 单链表
定义即为单链表。
- 双链表
	单链表中的指针域只指向节点的下一个节点。
	双链表：每一个节点有两个指针域，一个指向下一个节点，另一个指向上一个节点。
	因而双链表既可以向前查询，也可以向后查询。
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250324141006.png)
- 循环链表
	即链表首尾相连。
	循环链表可以用来解决约瑟夫环问题。
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250324141123.png)
## 链表的存储方式
	数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。
	链表是通过指针域的指针链接在内存中的各个节点。
## 链表节点的定义
	构造函数
```
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```
	另外，C++默认会生成一个构造函数，但这个构造函数不会初始化任何成员变量
	通过自己定义构造函数初始化节点：

```
ListNode* head = new ListNode(5);
```
	使用默认构造函数初始化节点：
```
ListNode* head = new ListNode();
head->val = 5;
```
	所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！
## 链表的操作
### 删除节点
删除D节点
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250324142142.png)
只需要将C节点的next指针指向E节点就可以了，
但D节点仍存在内存中，因而在C++中最好需要手动释放D节点，释放这块内存，
Java和Python有自动的内存回收机制，不需要手动释放。
### 添加节点
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250324142438.png)
添加F节点
## 链表性能分析
链表的删除和增加操作时间复杂度都是O(1)，也不会影响其他节点
但是，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。

|     | 插入/删除（时间复杂度） | 查询（时间复杂度） |       适用场景       |
| :-: | :----------: | :-------: | :--------------: |
| 数组  |     O(n)     |   O(1)    | 数据量固定，频繁查询，较少增删  |
| 链表  |     O(1)     |   O(n)    | 数据量不固定，频繁增删，较少查询 |
数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。
链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。
# 2.移除链表元素
## 题目
[203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)
题意：删除链表中等于给定值 val 的所有节点。
示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]
示例 2： 输入：head = [], val = 1 输出：[]
示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]
## 思路
[手把手带你学会操作链表 | LeetCode：203.移除链表元素_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV18B4y1s7R9/?vd_source=8c3dd385213da0072604192e9b535246)
- 使用原链表删除，只需让节点next指针直接指向下下一个节点就可以，但是需要注意手动清除内存，注意，头结点的删除，只需将head指针后移一位。
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250324144108.png)
头节点的移除
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250324144154.png)
- 使用虚拟头结点，就可以按照统一的逻辑进行操作
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250324144253.png)
## 解法
时间复杂度O(n)
空间复杂度O(1)
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        // //解法一：使用原链表进行删除
        // //删除头结点
        // while(head != nullptr && head->val == val){
        //     ListNode  *tem = head;
        //     head = head->next;
        //     delete tem;
        // }
        // //删除其他节点
        // ListNode *tem = head;
        // while(tem != nullptr && tem->next != nullptr){
        //     if(tem->next->val == val){
        //         ListNode *tem2 = tem->next;
        //         tem->next = tem->next->next;
        //         delete tem2;
        //     }else{
        //         tem = tem->next;
        //     }
        // }
        // return head;
        //==============================================
        // 解法二：使用虚拟头节点
        ListNode *dummyHead = new ListNode(val - 1); //虚拟节点的val设置为不等val的值
        dummyHead->next = head;
        ListNode *cur = dummyHead;
        while(cur->next != nullptr){
            if(cur->next->val == val){
                ListNode *tem = cur->next;
                cur->next = cur->next->next;
                delete tem;
            }
            else{
                cur = cur->next;
            }
        }
        head = dummyHead->next;
        delete dummyHead;
        return head;
    }
};
```