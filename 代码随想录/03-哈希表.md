# 1.哈希表基础

哈希表（Hash Table）是根据关键码的值而直接进行访问的数据结构
直白来讲其实数组就是一张哈希表，哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素
**一般哈希表都是用来快速判断一个元素是否出现集合里。**
例如要查询一个名字是否在这所学校里。
要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。
我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。
将学生姓名映射到哈希表上就涉及到了hash function ，也就是哈希函数。
## 哈希函数
 
哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。
哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。
![|400](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0.png)
如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？

此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个**取模**的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。

此时问题又来了，哈希表我们刚刚说过，就是一个数组。

	如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表同一个索引下标的位置。

接下来**哈希碰撞**就可以解决这个问题
## 哈希碰撞

如图所示，小李和小王都映射到了索引下标 1 的位置，**这一现象叫做哈希碰撞**。
![|400](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E.png)
一般哈希碰撞有两种解决方法， **拉链法**和**线性探测法**。
### 拉链法（链地址法）
刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了
![|300](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/%E6%8B%89%E9%93%BE%E6%B3%95.png)
（数据规模是dataSize， 哈希表的大小为tableSize）

其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。
### 线性探测法
使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。

例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。
![|275](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95.png)
### 举例说明
有一组数据  19 01 23 14 55 68 11 86 37要存储在表长11的数组中，其中H（key）=key MOD 11
按照线性探测法，取碰撞后后移一位
![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250328182612.png)
按照拉链法
![|275](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/20250328182721.png)
## 常见的三种哈希结构
当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。
- 数组
- set（集合）
- map（映射）

在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：

| 集合                 | 底层实现 | key是否有序 | key是否可以重复 | 能否更改key值 | 查询效率    | 增删效率    |
| ------------------ | ---- | ------- | --------- | -------- | ------- | ------- |
| std::set           | 红黑树  | 有序      | key不可重复   | 不可修改     | O(logn) | O(logn) |
| std::multiset      | 红黑树  | 有序      | key可重复    | 不可修改     | O(logn) | O(logn) |
| std::unordered_set | 哈希表  | 无序      | key不可重复   | 不可修改     | O(1)    | O(1)    |

std::unordered_set底层实现为哈希表
std::set 和std::multiset 的底层实现是红黑树

红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

| 映射                 | 底层实现 | key是否有序 | key值是否可以重复 | 能否更改key值 | 查询效率    | 增删效率    |
| ------------------ | ---- | ------- | ---------- | -------- | ------- | ------- |
| std::map           | 红黑树  | 有序      | key不可重复    | 不可修改     | O(logn) | O(logn) |
| std::multimap      | 红黑树  | 有序      | key可重复     | 不可修改     | O(logn) | O(logn) |
| std::unordered_map | 哈希表  | 无序      | key不可重复    | 不可修改     | O(1)    | O(1)    |

`std::unordered_map` 底层实现为哈希表
`std::map` 和`std::multimap` 的底层实现是红黑树

同理，`std::map` 和`std::multimap` 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。

当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

那么再来看一下map ，在map 是一个key-value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

# 2.有效的字母异位词（242，easy）
## 题目
[242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/description/)
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1: 输入: s = "anagram", t = "nagaram" 输出: true

示例 2: 输入: s = "rat", t = "car" 输出: false

**说明:** 你可以假设字符串只包含小写字母。
## 思路
[学透哈希表，数组使用有技巧！Leetcode：242.有效的字母异位词_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1YG411p7BA/?vd_source=8c3dd385213da0072604192e9b535246)

创建一个长度为26的哈希表，读取字符串每一个字符，存入哈希表

**数组其实就是一个简单哈希表**，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。

![](https://raw.githubusercontent.com/Leicha1/tuchuang/main/img/242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.gif)

定义一个数组叫做record用来上记录字符串s里字符出现的次数。

需要把字符映射到数组也就是哈希表的索引下标上，**因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。**

再遍历 字符串s的时候，**只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。** 这样就将字符串s中字符出现的次数，统计出来了。

那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。

那么最后检查一下，**record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。**

最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。
## 解法
```cpp
//自己写的
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};
        for(int i = 0; i < s.size(); i++)
            record[s[i] - 'a']++;
        for(int i = 0; i < t.size(); i++)
            record[t[i] - 'a']--;
        for(int i = 0; i < 26; i++){
            if(record[i] != 0)
                return false;
        }
        return true;
    }
};

//别人笔记，可以了解一下容器，集合，映射
//纯暴力
class Solution {
public:
    bool isAnagram(string s, string t) {  // 定义 isAnagram 方法，接受两个字符串参数
        if(s.length()!=t.length())  // 如果两个字符串的长度不同，直接返回 false，它们不可能互为字谜
            return false;
        sort(s.begin(),s.end());  // 对字符串 s 进行排序
        sort(t.begin(),t.end());  // 对字符串 t 进行排序
        return s==t;  // 返回字符串 s 和 t 是否完全相同
    }
};


//数组 容器
class Solution {
public:
    bool isAnagram(string s, string t) {  // 定义 isAnagram 方法，接受两个字符串参数
        int ans[26] = {0};  // 创建一个大小为 26 的整数数组 ans，用于记录每个字母出现的次数
        for (int i = 0; i < s.length(); i++)  // 遍历字符串 s
            ans[s[i] - 'a']++;  // 将字符 s[i] 出现的次数加一
        for (int i = 0; i < t.length(); i++)  // 遍历字符串 t
            ans[t[i] - 'a']--;  // 将字符 t[i] 出现的次数减一
        for (int i = 0; i < 26; i++)  // 遍历整数数组 ans
            if (ans[i] != 0)  // 如果有字母的出现次数不为零，说明两个字符串不互为字谜
                return false;
        return true;  // 遍历结束后，如果所有字母的出现次数都为零，则返回 true，说明两个字符串互为字谜
    }
};


//map 容器
class Solution {
public:
    bool isAnagram(string s, string t) {  // 定义 isAnagram 方法，接受两个字符串参数
        if (s.length() != t.length())  // 如果两个字符串的长度不同，那么它们不可能互为字谜，直接返回 false
            return false;
        unordered_map<char, int> map1;  // 定义 unordered_map 对象 map1，用于存储各个字符在字符串 s 中出现的次数
        for (char i : s)  // 遍历字符串 s，统计其中每个字符出现的次数，并将其存储在 map1 中
            map1[i]++;
        for (char i : t)  // 遍历字符串 t，对于其中的每个字符，减少其在 map1 中的计数器
            map1[i]--;
        for (auto it : map1) {  // 遍历 map1 中的所有键值对
            if (it.second != 0) {  // 如果有任何一个键值对的值不为零，则表示两个字符串不互为字谜，返回 false
                return false;
            }
        }
        return true;  // 所有键值对的值均为零，则表示两个字符串互为字谜，返回 true
    }
};

//set 容器
class Solution {
public:
    bool isAnagram(string s, string t) {  // 定义 isAnagram 方法，接受两个字符串参数
        if(s.length()!=t.length())   // 如果两个字符串的长度不同，直接返回 false，它们不可能互为字谜
            return false;
        unordered_map<char,int> set1;  // 创建一个无序映射容器 set1，用于记录每个字符出现的次数
        for(char i:s)
            set1[i]++;  // 遍历字符串 s 中的每个字符，将其出现次数加一
        for(char i:t)
            set1[i]--;  // 遍历字符串 t 中的每个字符，将其出现次数减一
       for (auto it : set1)  // 遍历 set1 中的每个键值对
        if (it.second != 0)  // 如果有字符的出现次数不为零，说明两个字符串不互为字谜
        return false;

        return true;  // 遍历结束后，如果所有字符的出现次数都为零，则返回 true，说明两个字符串互为字谜
    }
};
```

# 3.两个数组的交集（349，easy）
## 题目
[349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/description/)
给定两个数组 `nums1` 和 `nums2` ，返回 _它们的交集_ 。输出结果中的每个元素一定是**唯一**的。我们可以**不考虑输出结果的顺序** 。
**示例 1：**
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]

**示例 2：**
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的

**提示：**
- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 1000`
## 思路
[学透哈希表，set使用有技巧！Leetcode：349. 两个数组的交集_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ba411S7wu/?vd_source=8c3dd385213da0072604192e9b535246)
利用第一个数组构建哈希表，然后再遍历第二个数组，判断第二个数组里的元素是否存在于哈希表中，注意，结果需要去重

确定了使用哈希表，但还得选择合适的哈希结构，这里使用unordered_set,可以帮助直接去重，且适用于大小差异很大的数组。

这道题用暴力的解法时间复杂度是O(n^2)，那来看看使用哈希法进一步优化。

那么用数组来做哈希表也是不错的选择，例如2.有效的字母异位词（242，easy）

但是要注意，**使用数组来做哈希的题目，是因为题目都限制了数值的大小。**

而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。

**而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。**

此时就要使用另一种结构体了，set ，关于set，C++ 给提供了如下三种可用的数据结构：

- std::set
- std::multiset
- std::unordered_set

std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。
## 解法
```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set;
        unordered_set<int> num_set(nums1.begin(),nums1.end());
        for(auto num : nums2){
            if(num_set.find(num) != num_set.end())
                result_set.insert(num);
        }
        return vector<int>(result_set.begin(),result_set.end());
    }
};
```
# 4.快乐数（202，Easy）
## 题目
[202. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/description/)
编写一个算法来判断一个数 `n` 是不是快乐数。
**「快乐数」** 定义为：
- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。
如果 `n` 是 _快乐数_ 就返回 `true` ；不是，则返回 `false` 。

**示例 1：**
输入：n = 19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1

**示例 2：**
输入：n = 2
输出：false

**提示：**
- `1 <= n <= 2^31 - 1`
## 思路
